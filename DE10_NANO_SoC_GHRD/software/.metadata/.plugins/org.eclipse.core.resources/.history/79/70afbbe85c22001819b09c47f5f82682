#include "app.h"

int main ()
{
    INT8U os_err;

    BSP_WatchDog_Reset();                                       /* Reset the watchdog as soon as possible.              */

                                                                /* Scatter loading is complete. Now the caches can be activated.*/
    BSP_BranchPredictorEn();                                    /* Enable branch prediction.                            */
    BSP_L2C310Config();                                         /* Configure the L2 cache controller.                   */
    BSP_CachesEn();                                             /* Enable L1 I&D caches + L2 unified cache.             */


    CPU_Init();

    Mem_Init();

    BSP_Init();


    OSInit();

    void *ErrorMessageArray[100];
    void *MotorMessageArray[10];
    void *FuzzyMessageArray[10];

    //TODO: I'm pretty sure the below address is wrong. Need to test.
    ErrorQueue = OSQCreate(&ErrorMessageArray[0], 10);
    MotorQueue = OSQCreate(&MotorMessageArray[0], 10);
    FuzzyQueue = OSQCreate(&FuzzyMessageArray[0], 10);

    os_err = OSTaskCreateExt((void (*)(void *)) AppTaskStart,   /* Create the start task.                               */
                             (void          * ) 0,
                             (OS_STK        * )&AppTaskStartStk[TASK_STACK_SIZE - 1],
                             (INT8U           ) APP_TASK_PRIO,
                             (INT16U          ) APP_TASK_PRIO,  // reuse prio for ID
                             (OS_STK        * )&AppTaskStartStk[0],
                             (INT32U          ) TASK_STACK_SIZE,
                             (void          * )0,
                             (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));

    if (os_err != OS_ERR_NONE) {
        ; /* Handle error. */
    }
    os_err = OSTaskCreateExt((void (*)(void *)) MotorTask,   /* Create the start task.                               */
                             (void          * ) 0,
                             (OS_STK        * )&MotorTaskStk[TASK_STACK_SIZE - 1],
                             (INT8U           ) MOTOR_TASK_PRIO,
                             (INT16U          ) MOTOR_TASK_PRIO,  // reuse prio for ID
                             (OS_STK        * )&MotorTaskStk[0],
                             (INT32U          ) TASK_STACK_SIZE,
                             (void          * )0,
                             (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));

    if (os_err != OS_ERR_NONE) {
        ; /* Handle error. */
    }
    os_err = OSTaskCreateExt((void (*)(void *)) FuzzyTask,   /* Create the start task.                               */
                             (void          * ) 0,
                             (OS_STK        * )&FuzzyTaskStk[TASK_STACK_SIZE - 1],
                             (INT8U           ) FUZZY_TASK_PRIO,
                             (INT16U          ) FUZZY_TASK_PRIO,  // reuse prio for ID
                             (OS_STK        * )&FuzzyTaskStk[0],
                             (INT32U          ) TASK_STACK_SIZE,
                             (void          * )0,
                             (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));

    if (os_err != OS_ERR_NONE) {
        ; /* Handle error. */
    }

    os_err = OSTaskCreateExt((void (*)(void *)) ErrorTask,   /* Create the start task.                               */
                             (void          * ) 0,
                             (OS_STK        * )&ErrorTaskStk[TASK_STACK_SIZE - 1],
                             (INT8U           ) ERROR_TASK_PRIO,
                             (INT16U          ) ERROR_TASK_PRIO,  // reuse prio for ID
                             (OS_STK        * )&ErrorTaskStk[0],
                             (INT32U          ) TASK_STACK_SIZE,
                             (void          * )0,
                             (INT16U          )(OS_TASK_OPT_STK_CLR | OS_TASK_OPT_STK_CHK));

    if (os_err != OS_ERR_NONE) {
        ; /* Handle error. */
    }

    CPU_IntEn();

    OSStart();

}


/*
*********************************************************************************************************
*                                           App_TaskStart()
*
* Description : Startup task example code.
*
* Arguments   : p_arg       Argument passed by 'OSTaskCreate()'.
*
* Returns     : none.
*
* Created by  : main().
*
* Notes       : (1) The ticker MUST be initialised AFTER multitasking has started.
*********************************************************************************************************
*/

static  void  AppTaskStart (void *p_arg)
{

    BSP_OS_TmrTickInit(OS_TICKS_PER_SEC);                       /* Configure and enable OS tick interrupt.              */
    for(;;) {
        BSP_WatchDog_Reset();                                   /* Reset the watchdog.                                  */
        MoveFrontServo(0x00);
        //alt_write_byte(STEER_SERVO_BASE, 0x00);
        OSTimeDlyHMSM(0, 0, 0, 999);
        // 0x00 all the way to the left for the stopping servo
        //BSP_LED_On();
        //MoveFrontServo(0x00);
        //alt_write_byte(LEDR_BASE, 0x00);

        BSP_WatchDog_Reset();
        //MoveFrontServo(0x20);
        //alt_write_byte(STEER_SERVO_BASE, 0x10);
        //BSP_LED_Off();
        MoveFrontServo(0x10);
        //OSTimeDlyHMSM(0, 0, 0, 999);
        //MoveFrontServo(0x40);
        OSTimeDlyHMSM(0, 0, 0, 999);

        //////////// Steer Servo Range 0x00 - 0x31 (markings on body).  Wrap functions work.
        // For Actual use 0x00 - 0x10

        //////////// Back Servo Range 0x00 - 0x2E, 0x2F servo makes noise

        //alt_write_byte(LEDR_BASE, 0xff);
        // 0x2f all the way to the right for the stopping servo.
        //printf("FL4: %d\n", alt_read_byte(F_LEFT_BASE));
        //printf("FR5: %d\n", alt_read_byte(F_RIGHT_BASE));
        //printf("RL6: %d\n", alt_read_byte(R_LEFT_BASE));
        //printf("RR7: %d\n", alt_read_byte(R_RIGHT_BASE));
        //printf("sensor: %d\n", alt_read_byte(SONAR_BASE));
    }

}

//TODO: Change the queue names, they're confusing

static void MotorTask (void *p_arg)
{
	INT8U err;
	char *TaskName = "MotorTask";

    struct motorChangeMessage *msg;
    for(;;) {

        msg = (struct motorChangeMessage*)OSQPend(MotorQueue, 0, &err);

		switch(err)
        {
			case OS_NO_ERR:
				//Message was received

                float frontLeft = msg->frontLeft;
                //And etc...
                uint8_t steeringServo = msg->steeringServo;
                free(msg);
				/*
				Here's where you can actually do what you want to do
				*/


				break;

			default:
                struct errorMessage *msg = malloc(sizeof(errorMessage));
                msg->_taskName = TaskName;
                msg->_sourceName = "OSQPend";
                msg->_error = err;
                OSQPost(ErrorQueue, msg);
        }
    }
}

static void FuzzyTask (void *p_arg)
{
	INT8U err;
	char *TaskName = "FuzzyTask";

    struct motorSpeedMessage *msg;
    for(;;) {

        msg = (struct motorSpeedMessage*)OSQPend(FuzzyQueue, 0, &err);

		switch(err)
        {
			case OS_NO_ERR:
				//Message was received

                uint8_t frontLeft = msg->frontLeft;
                //And etc.

				/*
				Here's where you can actually do what you want to do
				*/

                struct motorChangeMessage *sentMessage;
                sentMessage = malloc(sizeof(motorChangeMessage));

                sentMessage->frontLeft = 0;
                //...

                OSQPost(FuzzyQueue, sentMessage);
				break;

			default:
				struct errorMessage *msg = malloc(sizeof(errorMessage));
				msg->_taskName = TaskName;
				msg->_sourceName = "OSQPend";
				msg->_error = err;
				OSQPost(ErrorQueue, msg);
        }
    }
}

static void ErrorTask (void *p_arg)
{
	INT8U err;

    struct errorMessage *msg;
    for(;;) {

        msg = (struct motorSpeedMessage*)OSQPend(FuzzyQueue, 0, &err);
        // Do something with the error.

        free(msg);
    }
}
